/** *  */package abhi.dispatcherserver;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.net.*;import java.lang.reflect.*;import abhi.utility.*;import abhi.utility.BaseSignal.SignalType;/** * @author abhisheksharma, dkrew0213 *This class is the Request Handler for the Dispatcher which handles each request in and individual separate thread.  * This means multiple instance of the client will be able to ask for requests without being blocked. * */public class ProxyDispatcherRequestHandler implements Runnable {   		private ProxyDispatcher proxyDispatcher; 	private Socket requestSocket = null;			public ProxyDispatcherRequestHandler(Socket socket, ProxyDispatcher proxyDispatcher)	{		this.proxyDispatcher = proxyDispatcher;		this.requestSocket = socket;	}		/* (non-Javadoc)	 * @see java.lang.Runnable#run()	 */	@Override	public void run() {				if(this.requestSocket == null){			try {				throw new Exception("Socket is invalid. Problem occured");			} catch (Exception e) {				e.printStackTrace();			}			}					BaseSignal signal = null;				try 		{			// Receiving			ObjectInputStream objStream = new ObjectInputStream(this.requestSocket.getInputStream());			signal = (BaseSignal) objStream.readObject();			SignalHandler(signal);			objStream.close();					} catch (IOException e) {			// TODO Auto-generated catch block			e.printStackTrace();		} catch (ClassNotFoundException e) {			// TODO Auto-generated catch block			e.printStackTrace();		}	}		public void SignalHandler(BaseSignal baseSignal)	{		switch(baseSignal.signalType)		{					case Invoke:								InvokeMethodSignal imSignal = (InvokeMethodSignal) baseSignal;								Object actualObject = this.proxyDispatcher.getAppropriateObject(imSignal.getClassName());				Object returnValue = null;								if(actualObject!=null)				{					try {						// Getting class context						Class<?> actualClass = imSignal.getClassinContext();						// Getting args				        Class<?>[] argstype = new Class[imSignal.getArguments().length];				        for (int i = 0; i < imSignal.getArguments().length; i++) {				          argstype[i] = imSignal.getArguments()[i].getClass();				        }				        				        // Getting method				        Method requestedMethod = actualClass.getMethod(imSignal.getMethodName(), argstype);				        System.out.println("Invoking the requested method " + actualClass.getName() + "."				                + requestedMethod.getName() + "() with " + imSignal.getArguments().length + " arguments.");				        				        try 				        {				        	// Invoke the method				        	System.out.println("output " + requestedMethod.getName());				        	System.out.println("imSignal.getArguments()" + imSignal.getArguments());							returnValue = requestedMethod.invoke(actualObject, imSignal.getArguments());							System.out.println("output " + returnValue);						} 				        catch (Exception e)						{				        	System.out.println("so i am b == " );				        	 e.printStackTrace();				        	try 				        	{								new ObjectOutputStream(this.requestSocket.getOutputStream()).writeObject(new InvocationResponseSignal(true,"Method Threw an Exception"));							} 				        	catch (IOException e1) {								// TODO Auto-generated catch block								e1.printStackTrace();							}						}											} catch (NoSuchMethodException e) {						// TODO Auto-generated catch block						e.printStackTrace();					} catch (SecurityException e) {						// TODO Auto-generated catch block						e.printStackTrace();					}										 try {						 //Everything is SuccessFUL SEND back the response					      System.out.println("Send back the result by an InvocationResponseMessage.\n");					      new ObjectOutputStream(this.requestSocket.getOutputStream()).writeObject(new InvocationResponseSignal(returnValue));					    } catch (IOException e) {					      e.printStackTrace();					    }				}				else				{					try 					{						new ObjectOutputStream(this.requestSocket.getOutputStream()).writeObject(new InvocationResponseSignal(true,"Object Not Present Remotely"));					} 					catch (IOException e) 					{						// TODO Auto-generated catch block						e.printStackTrace();					}				}				break;										default:				break;				}	}}